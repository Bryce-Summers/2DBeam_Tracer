// Generated by CoffeeScript 1.10.0

/*
    Beam Tracer Scene object.

    Written by Bryce Summers on 6/18/2016.
    
    Purpose:
     - This class represents and entire 2D Beam Tracer mathematical scene model.
    
    Components:
     - A linearSurfaceSet, which represents the set of surfaces that make up the geometry of the scene.
       This set also keeps a record of emmissive sources of light.
     - A camera that specifies the current view of the scene.
     - A set of Frustrums
 */

(function() {
  BT2D.BeamTracerScene = (function() {
    function BeamTracerScene() {
      this._surfaceSet = new BT2D.LinearSurfaceSet();
      this._lightFrustrumSet = new BT2D.LightFrustrumSet();
      this.frustrumsNeedUpdate = true;
      this.surfacesChanged = true;
      this._initCamera();
      this._frustrumTracer = new BT2D.FrustrumTracer();
      traceFrustrums();
    }

    BeamTracerScene.prototype._initCamera = function() {
      var height, width;
      width = 100;
      height = 100;
      this._camera = new THREE.OrthographicCamera(width / -2, width / 2, height / 2, height / -2, 1, 1000);
      return this._camera.position.z = 2;
    };

    BeamTracerScene.prototype.addSurface = function(surface) {
      this._surfaceSet.addSurface(surface);
      return this.surfacesChanged = true;
    };

    BeamTracerScene.prototype.traceFrustrums = function() {
      if (!this.surfacesChanged) {
        return;
      }
      this._frustrumTracer.traceFrustrums(this._surfaceSet, this._lightFrustrumSet);
      return this.surfacesChanged = false;
    };

    BeamTracerScene.prototype.frustrumsToTriangles = function(frustrumDrawer) {
      frustrumDrawer.clearTriangles();
      this._lightFrustrumSet.convertToTriangles(frustrumDrawer);
      return this.frustrumsNeedUpdate = false;
    };

    BeamTracerScene.prototype.getCamera = function() {
      return this._camera;
    };

    return BeamTracerScene;

  })();

}).call(this);

// Generated by CoffeeScript 1.10.0

/*
    LightFrustrumSet

    Written by Bryce Summers on 6/18/2016.
    
    Purpose:
    
        A set of frustrums illuminated via associated with spectrum attributes.
 */

(function() {
  BT2D.LightFrustrumSet = (function() {
    function LightFrustrumSet() {
      this._set = [];
    }

    LightFrustrumSet.prototype.addLightFrustrum = function(lightFrustrum) {
      return this._set.push(lightFrustrum);
    };

    convertToTriangles(frustrumDrawer)(function() {
      var frustrum, i, len, ref, results;
      ref = this._set;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        frustrum = ref[i];
        results.push(frustrum.convertToTriangles);
      }
      return results;
    });

    LightFrustrumSet.prototype.clearAll = function() {
      return this._set = [];
    };

    return LightFrustrumSet;

  })();

}).call(this);

// Generated by CoffeeScript 1.10.0

/*
    SurfaceSet

    Written by Bryce Summers on 6/18/2016.
    
    Purpose:
     - This class represents a set of Surfaces embedded in a plane.
     TODO : Think about whether I need to decompose this into linear vs. non-linear surfaces.
     - This class maintains the set through a spatial partitioning of the plane that allows for:
        - efficient ray - linearSurfaceSet intersections through spatial partitioning.
        - efficient frustrum - linearSurfaceSet intersections.
 */

(function() {
  BT2D.SurfaceSet = (function() {
    function SurfaceSet() {
      this._set = [];
      this._emmissive_set = [];
    }

    SurfaceSet.prototype.addSurface = function(surface) {
      this._set.push(surface);
      if (surface.isEmmissiveSource) {
        return this._emmissive_set.push(surface);
      }
    };

    SurfaceSet.prototype.emitSourceFrustrums = function() {
      var surface;
      return (function() {
        var i, len, ref, results;
        ref = this._emmissive_set;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          surface = ref[i];
          results.push(surface.emitSourceFrustrums());
        }
        return results;
      }).call(this);
    };

    SurfaceSet.prototype.intersectRay = function(ray, intersection) {
      var i, len, out, ref, surface;
      out = false;
      ref = this._set;
      for (i = 0, len = ref.length; i < len; i++) {
        surface = ref[i];
        out |= surface.intersectRay(ray, intersection);
      }
      return out;
    };

    return SurfaceSet;

  })();

}).call(this);

// Generated by CoffeeScript 1.10.0

/*
    The Frustrum drawer class.

    Written by Bryce Summers on 6/18/2016.
    Purpose:
     - This class speaks to Three.js
     - Renders all of the light frustrums to the screen as attribute interpolated triangles.
       where the attributes are the light intensities, represented by THREE.js Colors.
       
    Implementation Details:
     - We draw all of the attribute interpolated triangles with additive blending to sum up the total light contributions at any given point.
       since additive blending is commutative, we don't need to worry about z-fighting,
       even though all of the triangle will be drawn at the same depth.
     - We draw both front and back faces so that we don't need to waste time properly orienting the triangles.
 */

(function() {
  BT2D.FrustrumDrawer = (function() {
    function FrustrumDrawer() {
      this._geometry = new THREE.Geometry();
      this._scene = new THREE.Scene();
      this._material = new THREE.MeshBasicMaterial({
        vertexColors: THREE.VertexColors,
        side: THREE.DoubleSide,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthTest: false
      });
      this._mesh = new THREE.Mesh(this._geometry, this._material);
      this._scene.add(this._mesh);
    }

    FrustrumDrawer.prototype.addTriangle = function(v1, v2, v3, c1, c2, c3) {
      var face, i0, i1, i2;
      i0 = this._geometry.vertices.length;
      i1 = i0 + 1;
      i2 = i0 + 2;
      this._geometry.vertices.push(v1, v2, v3);
      face = new THREE.Face3(i0, i1, i2);
      face.vertexColors = [c1, c2, c3];
      this._geometry.faces.push(face);
      this._geometry.verticesNeedUpdate = true;
      return this._geometry.elementsNeedUpdate = true;
    };

    FrustrumDrawer.prototype.clearTriangles = function() {
      this._geometry.faces = [];
      this._geometry.vertices = [];
      this._geometry.verticesNeedUpdate = true;
      return this._geometry.elementsNeedUpdate = true;
    };

    FrustrumDrawer.prototype.render = function(renderer, tracerScene) {
      if (tracerScene.frustrumsNeedUpdate) {
        tracerScene.frustrumsToTriangles(this);
        return renderer.render(this._scene, tracerScene.getCamera());
      }
    };

    return FrustrumDrawer;

  })();

}).call(this);

// Generated by CoffeeScript 1.10.0

/*
    LightFrustrum

    Written by Bryce Summers on 6/18/2016.
    
    Purpose:
    
        This class represents a frustrum illuminated via
        spectrum paths.
        
    Representation the colors coorespond to the vertices in the following order:
            start1(), start2(), getEnd2(), frustrum.getEnd1()
 */

(function() {
  BT2D.LightFrustrum = (function() {
    function LightFrustrum(frustrum1, spectrum1, spectrum2, spectrum3, spectrum4) {
      this.frustrum = frustrum1;
      this.spectrum1 = spectrum1;
      this.spectrum2 = spectrum2;
      this.spectrum3 = spectrum3;
      this.spectrum4 = spectrum4;
    }

    LightFrustrum.prototype.convertToTriangles = function(frustrumDrawer) {
      var c1, c2, c3, c4, v1, v2, v3, v4;
      v1 = frustrum.getStart1();
      v2 = frustrum.getStart2();
      v3 = frustrum.getEnd2();
      v4 = frustrum.getEnd1();
      c1 = this.spectrum1.toColor();
      c2 = this.spectrum2.toColor();
      c3 = this.spectrum3.toColor();
      c4 = this.spectrum4.toColor();
      frustrumDrawer.addTriangle(v1, v2, v3, c1, c2, c3);
      return frustrumDrawer.addTriangle(v1, v2, v3, c1, c2, c3);
    };

    return LightFrustrum;

  })();

}).call(this);

// Generated by CoffeeScript 1.10.0

/*
    Material

    Written by Bryce Summers on 6/18/2016.
    
    Purpose:
     - This class specifies the Bdrf and other light transport properties of a surface.
     - In otherwords, this class specifies how to an input frustrum with an associated spectrum
       gets transformed into outgoing spectrums.
       
     - Every piece of geometry needs to be associated with a material in order to interact with spectrum frustrums.
 */

(function() {
  BT2D.Material = (function() {
    function Material() {
      this.emmisive = new BT2D.spectrum();
    }

    Material.prototype.isEmmissiveSource = function() {
      return !this.emmissive.imperceptible;
    };

    return Material;

  })();

}).call(this);

// Generated by CoffeeScript 1.10.0

/*
    Spectrum object.

    Written by Bryce Summers on 6/18/2016.
    
    Purpose:
     - This class represents an Electromagnetic radiation spectrum.
     
    What does that mean?
 */

(function() {
  BT2D.Spectrum = (function() {
    function Spectrum(red1, green1, blue1) {
      this.red = red1;
      this.green = green1;
      this.blue = blue1;
    }

    Spectrum.prototype.imperceptible = function() {
      return this.red + this.green + this.blue < .01;
    };

    Spectrum.prototype.toColor = function() {
      return new THREE.Color(red, green, blue);
    };

    Spectrum.prototype.mult = function(other) {
      return new BT2D.Spectrum(this.red * other.red, this.green * other.green, this.blue * other.blue);
    };

    Spectrum.prototype.multScalar = function(s) {
      return new BT2D.Spectrum(this.red * s, this.green * s, this.blue * s);
    };

    Spectrum.prototype.add = function(other) {
      return new BT2D.Spectrum(this.red + other.red, this.green + other.green, this.blue + other.blue);
    };

    return Spectrum;

  })();

}).call(this);

// Generated by CoffeeScript 1.10.0

/*
    Surface

    Written by Bryce Summers on 6/18/2016.
    
    Purpose:
        This class describes a physical surface that associates a geoemtry with a material.
         - The geometry describes an embedding in space.
         - The material describes the light tranport properties of this surface.
 */

(function() {
  BT2D.Surface = (function() {
    function Surface(geometry1, material1) {
      this.geometry = geometry1;
      this.material = material1;
    }

    Surface.prototype.isEmmissiveSource = function() {
      return material.isEmmissiveSource;
    };

    emitSourceFrustrums()(function() {
      var dir, p1, p2;
      if (this.geometry(typeof BT2D.Line)) {
        p1 = line.getP1();
        p2 = line.getP2();
        dir = line.getNormal();
        return new BT2D.Frustrum(p1, p2, dir, dir);
      }
      return console.log("ERROR: NON-line emmissive surfaces are not supported yet.");
    });

    emitScatteringFrustrums(incomingFrustrum)(function() {});

    intersectRay(ray, intersection)(function() {
      return geometry.intersectRay(ray, intersection);
    });

    return Surface;

  })();

}).call(this);

// Generated by CoffeeScript 1.10.0

/*
    Radial Test Scene Generator object.

    Written by Bryce Summers on 6/18/2016.
    
    Purpose:
     - This class generates a new Radia Test Scene to be used as an example scene for testing the frustrum renderer.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  BT2D.RadialTestScene = (function(superClass) {
    extend(RadialTestScene, superClass);

    function RadialTestScene() {}

    return RadialTestScene;

  })(BT2D.BeamTracerScene);

}).call(this);

// Generated by CoffeeScript 1.10.0

/*
    FrustrumTracer class

    Written by Bryce Summers on 6/18/2016.

    Purpose:
     - This class traces frustrums, given a surface model of the scene.

     - This is very similar to a traditional ray tracer, just more exciting.
 */

(function() {
  BT2D.FrustrumTracer = (function() {
    function FrustrumTracer() {}

    FrustrumTracer.prototype.traceFrustrums = function(surfaceSet, lightFrustrumSet) {
      var frustrum, i, initial_frustrums, j, len, len1, lightFrustrum, lightFrustrums, results;
      lightFrustrumSet.clearAll();
      initial_frustrums = surfaceSet.emitSourceFrustrums();
      for (i = 0, len = initial_frustrums.length; i < len; i++) {
        frustrum = initial_frustrums[i];
        lightFrustrums = this.traceFrustrum(frustrum, surfaceSet);
      }
      results = [];
      for (j = 0, len1 = lightFrustrums.length; j < len1; j++) {
        lightFrustrum = lightFrustrums[j];
        results.push(lightFrustrumSet.addLightFrustrum);
      }
      return results;
    };

    traceFrustrum(frustrum, surfaceSet);

    return FrustrumTracer;

  })();

}).call(this);

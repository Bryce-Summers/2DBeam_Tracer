// Generated by CoffeeScript 1.10.0

/*
    Surface

    Written by Bryce Summers on 6/18/2016.
    
    Purpose:
        This class describes a physical surface that associates a geoemtry with a material.
         - The geometry describes an embedding in space.
         - The material describes the light tranport properties of this surface.
 */

(function() {
  BT2D.Surface = (function() {
    function Surface(_geometry, _material) {
      this._geometry = _geometry;
      this._material = _material;
    }

    Surface.prototype.isEmissiveSource = function() {
      return this._material.isEmissiveSource();
    };

    Surface.prototype.emitSourceFrustrums = function() {
      var dir, frustrum, initial_spectrum, lightFrustrum, line, p1, p2;
      if (this._geometry instanceof BT2D.Line) {
        line = this._geometry;
        p1 = line.getP1();
        p2 = line.getP2();
        dir = line.getNormal();
        frustrum = new BT2D.Frustrum(p1, p2, dir, dir);
        initial_spectrum = this._material.getEmmissiveSourceSpectrum();
        lightFrustrum = new BT2D.LightFrustrum(frustrum, initial_spectrum, initial_spectrum, this._geometry, 0);
        return [lightFrustrum];
      }
      return console.log("ERROR: NON-line emmissive surfaces are not supported yet.");
    };

    Surface.prototype.emitScatteringFrustrums = function(incomingLightFrustrum, output) {
      var bounces_incoming, end1, end2, incoming_dir1, incoming_dir2, input_frustrum, lightFrustrum, line, outgoing_dir1, outgoing_dir2, perp_1, perp_2, ref, scattered_frustrum, spectrum_1, spectrum_2;
      input_frustrum = incomingLightFrustrum.frustrum;
      if (this._geometry instanceof BT2D.Line) {
        bounces_incoming = incomingLightFrustrum.getNumBounces();
        if (bounces_incoming >= BT2D.Constants.MAX_BOUNCES) {
          return false;
        }
        spectrum_1 = incomingLightFrustrum.getEndSpectrum2();
        spectrum_2 = incomingLightFrustrum.getEndSpectrum1();
        if (spectrum_1.imperceptible() && spectrum_2.imperceptible()) {
          return false;
        }
        incoming_dir1 = input_frustrum.getDir2();
        incoming_dir2 = input_frustrum.getDir1();
        ref = this._material.transformSpectrums(spectrum_1, spectrum_2, incoming_dir1, incoming_dir2), spectrum_1 = ref[0], spectrum_2 = ref[1];
        if (spectrum_1.imperceptible() && spectrum_2.imperceptible()) {
          return false;
        }
        line = this._geometry;
        outgoing_dir1 = line.getPerfectSpecularReflectionDirection(incoming_dir1);
        outgoing_dir2 = line.getPerfectSpecularReflectionDirection(incoming_dir2);
        perp_1 = line.getPerpendicularPercentage(incoming_dir1);
        perp_2 = line.getPerpendicularPercentage(incoming_dir2);
        end1 = input_frustrum.getEnd2();
        end2 = input_frustrum.getEnd1();

        /*
        Let us stop being scared and not fudge this the wrong way.
        end1.sub(incoming_dir1.multiplyScalar(BT2D.Constants.EPSILON*2/perp_1))
        end2.sub(incoming_dir2.multiplyScalar(BT2D.Constants.EPSILON*2/perp_2))
         */
        if (end1.clone().sub(end2).length() < BT2D.Constants.MINNIMUM_SCATTER_SEPARATION && outgoing_dir1.clone().dot(outgoing_dir2) > 1.0 - BT2D.Constants.EPSILON) {
          return;
        }
        scattered_frustrum = new BT2D.Frustrum(end1, end2, outgoing_dir1, outgoing_dir2);
        lightFrustrum = new BT2D.LightFrustrum(scattered_frustrum, spectrum_1, spectrum_2, this._geometry, bounces_incoming);
        lightFrustrum.scatteredFrom(incomingLightFrustrum, this);
        output.push(lightFrustrum);
        return true;
      }
      return console.log("ERROR: Non-line surfaces are currently not supported for light scattering.");
    };

    Surface.prototype.intersectRay = function(ray, intersection, min_time) {
      if (this._geometry.intersectRay(ray, intersection, min_time)) {
        intersection.surface = this;
        return true;
      } else {
        return false;
      }
    };

    Surface.prototype.intersectFrustrum = function(frustrum, min_time1, min_time2) {
      var found, left, ref, right, surface;
      ref = this._geometry.intersectFrustrum(frustrum, min_time1, min_time2), found = ref[0], left = ref[1], right = ref[2], surface = ref[3];
      if (found) {
        surface = this;
      }
      return [found, left, right, surface];
    };

    Surface.prototype.split = function(bp) {
      var left, left_output, middle, middle_output, ref, right, right_output;
      ref = this._geometry.split(bp), left = ref[0], middle = ref[1], right = ref[2];
      left_output = null;
      middle_output = null;
      right_output = null;
      if (left !== null) {
        left_output = new BT2D.Surface(left, this._material);
      }
      if (right !== null) {
        right_output = new BT2D.Surface(right, this._material);
      }
      if (middle !== null) {
        middle_output = new BT2D.Surface(middle, this._material);
      }
      return [left_output, middle_output, right_output];
    };

    Surface.prototype.getBP = function() {
      if (this._geometry instanceof BT2D.Line) {
        return this._geometry;
      }
      return console.log("ERROR: For non lines, e.g. circles and whatnot, we need to support area containing binary classifiers.");
    };

    return Surface;

  })();

}).call(this);

// Generated by CoffeeScript 1.10.0

/*
    LightFrustrum

    Written by Bryce Summers on 6/18/2016.
    
    Purpose:
    
        This class represents a frustrum illuminated via
        spectrum paths.
        
    Representation the colors coorespond to the vertices in the following order:
            start1(), start2(), getEnd2(), frustrum.getEnd1()

    The LightFrustrum is said to be complete then it has all 4 points, but imcomplete it it only has the near points defined.

    The source geometry is the geometry that radiated this light frustrum.
    It will be required to ensure that we do not allow a light frustrum to intersect its source, while also allowing light frustrums to intersect geometries
    that intersect the source at the starting points.

    FIXME: I might want to go an make all of these variables private when I get a chance.

    My idea for maintaining this as it gets more complex is to make clones of light frustrums, then only mutate those values as necessary.
 */

(function() {
  BT2D.LightFrustrum = (function() {
    function LightFrustrum(frustrum, spectrum1, spectrum2) {
      this.frustrum = frustrum;
      this.spectrum1 = spectrum1;
      this.spectrum2 = spectrum2;
      this.spectrum3 = null;
      this.spectrum4 = null;
      this._bounces = 0;
      this._source_geometry = null;
    }

    LightFrustrum.prototype.complete = function(end1, end2, dist1, dist2) {
      if (end1.clone().sub(end2).length() < .001) {
        console.log("ERROR: Bad completion. 2D Beam tracer frustrums are guranteed to never intersect the same end points.");
      }
      this.frustrum.complete(end1, end2);
      this.spectrum4 = this.spectrum1.decay(dist1);
      return this.spectrum3 = this.spectrum2.decay(dist2);
    };

    LightFrustrum.prototype.clone = function() {
      var output;
      output = new BT2D.LightFrustrum(this.frustrum, this.spectrum1, this.spectrum2, this.source_geometry);
      output._bounces = this._bounces;
      return output;
    };

    LightFrustrum.prototype.getEndSpectrum1 = function() {
      return this.spectrum4.clone();
    };

    LightFrustrum.prototype.getEndSpectrum2 = function() {
      return this.spectrum3.clone();
    };

    LightFrustrum.prototype.scatteredFrom = function(parentLightFrustrum, surface) {
      this._bounces = parentLightFrustrum.getNumBounces() + 1;
      return this._souce_geometry = surface;
    };

    LightFrustrum.prototype._copyStatisticsFrom = function(other) {
      this._bounces = other._bounces;
      return this._source_geometry = other._source_geometry;
    };

    LightFrustrum.prototype.getNumBounces = function() {
      return this._bounces;
    };

    LightFrustrum.prototype.convertToTriangles = function(frustrumDrawer) {
      var c1, c2, c3, c4, v1, v2, v3, v4;
      if (this.spectrum3 === null || this.spectrum4 === null) {
        console.log("Incomplete Frustrum, likely no intersection was found during tracing.");
        return;
      }
      v1 = this.frustrum.getStart1();
      v2 = this.frustrum.getStart2();
      v3 = this.frustrum.getEnd2();
      v4 = this.frustrum.getEnd1();
      c1 = this.spectrum1.toColor();
      c2 = this.spectrum2.toColor();
      c3 = this.spectrum3.toColor();
      c4 = this.spectrum4.toColor();
      frustrumDrawer.addTriangle(v1, v2, v3, c1, c2, c3);
      return frustrumDrawer.addTriangle(v3, v4, v1, c3, c4, c1);
    };

    LightFrustrum.prototype.splitLeft = function(pt) {
      var left_frustrum, output, percentage, ref, split_ray, split_spectrum;
      ref = this.frustrum.getSplitRay(pt), split_ray = ref[0], percentage = ref[1];
      if (percentage > 1.0 - BT2D.Constants.EPSILON * 10 || percentage < 0.0 + BT2D.Constants.EPSILON * 10) {
        console.log("WARNING: A trivial splitLeft was attempted.");
        return null;
      }
      left_frustrum = new BT2D.Frustrum(this.frustrum.getStart1(), split_ray.getOrigin(), this.frustrum.getDir1(), split_ray.getDirection());
      split_spectrum = this.spectrum1.multScalar(percentage).add(this.spectrum2.multScalar(1.0 - percentage));
      output = new BT2D.LightFrustrum(left_frustrum, this.spectrum1, split_spectrum);
      output._copyStatisticsFrom(this);
      this.spectrum1 = split_spectrum;
      this.frustrum.setLeftRay(split_ray);
      return output;
    };

    LightFrustrum.prototype.splitRight = function(pt) {

      /*
      This is where the problem happens.
       */
      var output, percentage, ref, right_frustrum, split_ray, split_spectrum;
      ref = this.frustrum.getSplitRay(pt), split_ray = ref[0], percentage = ref[1];
      if (percentage > 1.0 - BT2D.Constants.EPSILON * 10 || percentage < 0.0 + BT2D.Constants.EPSILON * 10) {
        console.log("WARNING: A trivial splitRight was attempted.");
        debugger;
        return null;
      }
      right_frustrum = new BT2D.Frustrum(split_ray.getOrigin(), this.frustrum.getStart2(), split_ray.getDirection(), this.frustrum.getDir2());
      split_spectrum = this.spectrum1.multScalar(percentage).add(this.spectrum2.multScalar(1.0 - percentage));
      output = new BT2D.LightFrustrum(right_frustrum, split_spectrum, this.spectrum2);
      output._copyStatisticsFrom(this);
      this.spectrum2 = split_spectrum;
      this.frustrum.setRightRay(split_ray);
      return output;
    };

    LightFrustrum.prototype.getSplitRay = function(pt) {
      var percentage, ref, split_ray;
      ref = this.frustrum.getSplitRay(pt), split_ray = ref[0], percentage = ref[1];
      return split_ray;
    };

    LightFrustrum.prototype.getOrientationRay = function(pt) {
      return this.frustrum.getOrientationRay(pt);
    };

    return LightFrustrum;

  })();

}).call(this);

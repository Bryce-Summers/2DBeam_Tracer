// Generated by CoffeeScript 1.10.0

/*
    FrustrumTracer class

    Written by Bryce Summers on 6/18/2016.

    Purpose:
     - This class traces frustrums, given a surface model of the scene.

     - This is very similar to a traditional ray tracer, just more exciting.
 */

(function() {
  BT2D.FrustrumTracer = (function() {
    function FrustrumTracer() {}

    FrustrumTracer.prototype.traceFrustrums = function(surfaceSet, lightFrustrumSet) {
      var i, incomplete_frustrum_set, lightFrustrum, results, scattered_frustrum, scattered_frustrum_set;
      lightFrustrumSet.clearAll();
      incomplete_frustrum_set = surfaceSet.emitSourceFrustrums();
      i = 0;
      results = [];
      while (i < incomplete_frustrum_set.length) {
        lightFrustrum = incomplete_frustrum_set[i];
        i++;
        scattered_frustrum_set = this._traceFrustrum(lightFrustrum, surfaceSet);
        lightFrustrumSet.addLightFrustrum(lightFrustrum);
        results.push((function() {
          var j, len, results1;
          results1 = [];
          for (j = 0, len = scattered_frustrum_set.length; j < len; j++) {
            scattered_frustrum = scattered_frustrum_set[j];
            results1.push(incomplete_frustrum_set.push(scattered_frustrum));
          }
          return results1;
        })());
      }
      return results;
    };

    FrustrumTracer.prototype._traceFrustrum = function(lightFrustrum, surfaceSet) {
      var dist1, dist2, end1, end2, frustrum, intersection, ray1, ray2, surface;
      intersection = new BT2D.Intersection();
      frustrum = lightFrustrum.frustrum;
      ray1 = new BT2D.Ray(frustrum.getStart1(), frustrum.dir1);
      ray2 = new BT2D.Ray(frustrum.getStart2(), frustrum.dir2);
      end1 = null;
      end2 = null;
      dist1 = null;
      dist2 = null;
      if (surfaceSet.intersectRay(ray1, intersection, BT2D.Constants.EPSILON)) {
        end1 = intersection.computePosition(ray1);
        dist1 = intersection.time;
      } else {
        console.log("ERROR: We are not able to properly handle view bounded frustrums yet.");
        return [];
      }
      if (surfaceSet.intersectRay(ray2, intersection, BT2D.Constants.EPSILON)) {
        end2 = intersection.computePosition(ray2);
        dist2 = intersection.time;
      } else {
        console.log("ERROR: We are not able to properly handle view bounded frustrums yet.");
        return [];
      }
      if (end1 !== null && end2 !== null) {
        lightFrustrum.complete(end1, end2, dist1, dist2);
      }
      surface = intersection.surface;
      return surface.emitScatteringFrustrums(lightFrustrum, intersection);
    };

    return FrustrumTracer;

  })();

}).call(this);

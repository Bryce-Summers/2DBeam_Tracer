// Generated by CoffeeScript 1.10.0

/*
    FrustrumTracer class

    Written by Bryce Summers on 6/18/2016.

    Purpose:
     - This class traces frustrums, given a surface model of the scene.

     - This is very similar to a traditional ray tracer, just more exciting.
 */

(function() {
  BT2D.FrustrumTracer = (function() {
    function FrustrumTracer() {}

    FrustrumTracer.prototype.traceFrustrums = function(surfaceSet, lightFrustrumSet) {
      var i, incomplete_frustrum_set, lightFrustrum, results, scattered_frustrum, scattered_frustrum_set;
      lightFrustrumSet.clearAll();
      incomplete_frustrum_set = surfaceSet.emitSourceFrustrums();
      incomplete_frustrum_set = this.addPointLight();
      i = 0;
      results = [];
      while (i < incomplete_frustrum_set.length) {
        if (i > 2000) {
          console.log("Too many Frustrums, loop broken.");
          break;
        }
        lightFrustrum = incomplete_frustrum_set[i];
        i++;
        scattered_frustrum_set = this._traceFrustrum(lightFrustrum, surfaceSet);
        if (scattered_frustrum_set === null) {
          continue;
        }
        lightFrustrumSet.addLightFrustrum(lightFrustrum);
        results.push((function() {
          var j, len, results1;
          results1 = [];
          for (j = 0, len = scattered_frustrum_set.length; j < len; j++) {
            scattered_frustrum = scattered_frustrum_set[j];
            results1.push(incomplete_frustrum_set.push(scattered_frustrum));
          }
          return results1;
        })());
      }
      return results;
    };

    FrustrumTracer.prototype.addPointLight = function() {
      var NE, NW, center, down, f0, f1, full, fullIntensitySpectrum, left, lightf0, lightf1, noIntensitySpectrum, redSpectrum, right, up;
      center = new THREE.Vector3(BT2D.mouse_x + .0000123749, BT2D.mouse_y + .0000012937129, 0);
      left = new THREE.Vector3(-1, 0, 0);
      right = new THREE.Vector3(1, 0, 0);
      up = new THREE.Vector3(0, 1, 0);
      down = new THREE.Vector3(0, -1, 0);
      NW = new THREE.Vector3(-1, 2, 0);
      NE = new THREE.Vector3(1, 2, 0);
      fullIntensitySpectrum = new BT2D.Spectrum(1.0, 1.0, 1.0);
      noIntensitySpectrum = new BT2D.Spectrum(0.0, 0.0, 0.0);
      redSpectrum = new BT2D.Spectrum(1.0, 0.0, 0.0);
      full = redSpectrum;
      f0 = new BT2D.Frustrum(center, center, left, right);
      lightf0 = new BT2D.LightFrustrum(f0, full, full, null);
      f1 = new BT2D.Frustrum(center, center, right, left);
      lightf1 = new BT2D.LightFrustrum(f1, full, full, null);
      return [lightf0, lightf1];
    };

    FrustrumTracer.prototype._traceFrustrum = function(lightFrustrum, surfaceSet) {
      var found, left, output, ref, right, surface;
      ref = surfaceSet.intersectFrustrum(lightFrustrum, 0, 0), found = ref[0], left = ref[1], right = ref[2], surface = ref[3];
      if (!found) {
        console.log("ERROR: Frustrum was not properly completed.");
        debugger;
        return null;
      }
      output = [];
      if (left !== null) {
        output.push(left);
      }
      if (right !== null) {
        output.push(right);
      }
      surface.emitScatteringFrustrums(lightFrustrum, output);
      return output;
    };

    FrustrumTracer.prototype._traceFrustrumNaive = function(lightFrustrum, surfaceSet) {
      var dist1, dist2, end1, end2, frustrum, intersection, output, ray1, ray2, surface;
      intersection = new BT2D.Intersection();
      frustrum = lightFrustrum.frustrum;
      ray1 = new BT2D.Ray(frustrum.getStart1(), frustrum.getDir1());
      ray2 = new BT2D.Ray(frustrum.getStart2(), frustrum.getDir2());
      end1 = null;
      end2 = null;
      dist1 = null;
      dist2 = null;
      if (surfaceSet.intersectRay(ray1, intersection, BT2D.Constants.EPSILON)) {
        end1 = intersection.computePosition(ray1);
        dist1 = intersection.time;
      } else {
        debugger;
        console.log("ERROR: We are not able to properly handle view bounded frustrums yet.");
        return [];
      }
      intersection.clear();
      if (surfaceSet.intersectRay(ray2, intersection, BT2D.Constants.EPSILON)) {
        end2 = intersection.computePosition(ray2);
        dist2 = intersection.time;
      } else {
        debugger;
        console.log("ERROR: We are not able to properly handle view bounded frustrums yet.");
        return [];
      }
      if (end1 !== null && end2 !== null) {
        lightFrustrum.complete(end1, end2, dist1, dist2);
      }
      surface = intersection.surface;
      output = [];
      surface.emitScatteringFrustrums(lightFrustrum, output);
      return output;
    };

    return FrustrumTracer;

  })();

}).call(this);

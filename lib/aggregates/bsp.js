// Generated by CoffeeScript 1.10.0

/*
    binary Space Partitioning Tree.

    Written by Bryce Summers on 6/26/2016.
    
    Purpose:
     - This class enable efficient geometric queries by partitioning planar space using surfaces.
 */

(function() {
  BT2D.BSP = (function() {

    /*
    
        Creating the BSP.
     */
    function BSP(surface_set) {
      var bp_surface, left, middle, ref, ref1, right;
      if (surface_set.length === 0) {
        console.log("ERROR, surface set should be non trivial.");
        debugger;
      }
      this._left = null;
      this._set = null;
      this._right = null;
      this._bp = null;
      ref = this._choosePartitioner(surface_set), this._bp = ref[0], bp_surface = ref[1];
      ref1 = this._partitionInput(surface_set, this._bp, bp_surface), left = ref1[0], middle = ref1[1], right = ref1[2];
      if (left.length > 0) {
        this._left = new BT2D.BSP(left);
      }
      if (right.length > 0) {
        this._right = new BT2D.BSP(right);
      }
      if (middle.length > 0) {
        this._set = new BT2D.LeafSurfaceSet(middle);
      } else {
        console.log("ERROR: we assume that @_set is always well defined.");
      }
    }

    BSP.prototype._choosePartitioner = function(surfaceSet) {
      var surface;
      surface = surfaceSet[0];
      return [surface.getBP(), surface];
    };

    BSP.prototype._partitionInput = function(surfaceSet, bp, middle_surface) {
      var i, left, left_surface, len, middle, ref, right, right_surface, surface;
      left = [];
      middle = [];
      right = [];
      for (i = 0, len = surfaceSet.length; i < len; i++) {
        surface = surfaceSet[i];
        if (surface === middle_surface) {
          middle.push(middle_surface);
          continue;
        }
        ref = surface.split(bp), left_surface = ref[0], middle_surface = ref[1], right_surface = ref[2];
        if (left_surface !== null) {
          left.push(left_surface);
        }
        if (middle_surface !== null) {
          middle.push(middle_surface);
        }
        if (right_surface !== null) {
          right.push(right_surface);
        }
      }
      return [left, middle, right];
    };


    /*
    
        Search Queries using the BSP.
     */

    BSP.prototype.intersectRay = function(ray, intersection, min_time) {
      var bp_intersection_time, classification, otherSide, pt, ptSide, ref;
      pt = ray.getPosition(min_time);
      classification = this._bp.side_test(pt);
      ref = this._orientChildSets(classification), ptSide = ref[0], otherSide = ref[1];
      if (ptSide !== null && ptSide.intersectRay(ray, intersection, min_time)) {
        return true;
      }
      if (this._set.intersectRay(ray, intersection, min_time)) {
        return true;
      }
      if (otherSide === null) {
        return false;
      }
      bp_intersection_time = this._bp.ray_partition_intersection_time(ray);
      if (bp_intersection_time < min_time) {
        return false;
      }
      return otherSide.intersectRay(ray, intersection, bp_intersection_time);
    };

    BSP.prototype._orientChildSets = function(classification) {
      switch (classification) {
        case BT2D.Constants.LEFT:
          return [this._left, this._right];
        case BT2D.Constants.RIGHT:
          return [this._right, this._left];
        case BT2D.Constants.ON:
          console.log("ERROR: We are assuming starting points that are not on a binary classification boundary.");
          return [this._left, this._right];
      }
    };

    BSP.prototype.intersectFrustrum = function(lightFrustrum, min_time1, min_time2) {
      var bp_left, bp_right, classification_left, classification_right, classifier, focus, found, frustrum, frustrum_side, left_frustrum, otherSide, pt_left, pt_right, ray_left, ray_right, ref, ref1, ref2, ref3, right_frustrum, surface, time1, time2;
      frustrum = lightFrustrum.frustrum;
      bp_left = frustrum.getLeftBP();
      bp_right = frustrum.getRightBP();
      pt_left = bp_left.getPosition(min_time1 + BT2D.Constants.EPSILON * 2);
      pt_right = bp_right.getPosition(min_time2 + BT2D.Constants.EPSILON * 2);
      classification_left = this._bp.side_test(pt_left);
      classification_right = this._bp.side_test(pt_right);
      if (classification_left === BT2D.Constants.ON || classification_right === BT2D.Constants.ON) {
        console.log("ERROR: Assumption invalidated, frustum not offset into cell interior, try using a fudge factor.");
      }
      ray_left = bp_left;
      ray_right = bp_right;
      time1 = this._bp.ray_partition_intersection_time(ray_left);
      time2 = this._bp.ray_partition_intersection_time(ray_right);
      if (classification_left === classification_right) {
        classifier = classification_left;
      } else if (time1 === BT2D.Constants.NO_INTERSECTION && time2 !== BT2D.Constants.NO_INTERSECTION) {
        classifier = classification_right;
      } else if (time1 !== BT2D.Constants.NO_INTERSECTION && time2 === BT2D.Constants.NO_INTERSECTION) {
        classifier = classification_left;
      } else {
        focus = frustrum.getFocusPoint();
        if (focus === null) {
          classifier = classification_left;
        } else {
          classifier = this._bp.side_test(focus);
        }
      }
      ref = this._orientChildSets(classifier), frustrum_side = ref[0], otherSide = ref[1];
      found = false;
      left_frustrum = null;
      right_frustrum = null;
      surface = null;
      if (frustrum_side !== null) {
        ref1 = frustrum_side.intersectFrustrum(lightFrustrum, min_time1, min_time2), found = ref1[0], left_frustrum = ref1[1], right_frustrum = ref1[2], surface = ref1[3];
      }
      if (found) {
        return [true, left_frustrum, right_frustrum, surface];
      }
      if (time1 === BT2D.Constants.NO_INTERSECTION && time2 === BT2D.Constants.NO_INTERSECTION) {
        return [false, null, null];
      }
      if (time1 === BT2D.Constants.NO_INTERSECTION) {

        /*
        console.log("Does SLANT LEFT really happen?")
        console.log("Yes is does!")
         */
      }
      if (time2 === BT2D.Constants.NO_INTERSECTION) {

        /*
        console.log("Does this case actually happen?")
        console.log("Yes is does!")
         */
      }
      ref2 = this._set.intersectFrustrum(lightFrustrum, min_time1, min_time2), found = ref2[0], left_frustrum = ref2[1], right_frustrum = ref2[2], surface = ref2[3];
      if ((!found) && otherSide !== null) {
        ref3 = otherSide.intersectFrustrum(lightFrustrum, time1 - BT2D.Constants.EPSILON, time2 - BT2D.Constants.EPSILON), found = ref3[0], left_frustrum = ref3[1], right_frustrum = ref3[2], surface = ref3[3];
      }
      return [found, left_frustrum, right_frustrum, surface];
    };

    return BSP;

  })();

}).call(this);

// Generated by CoffeeScript 1.10.0

/*
    binary Space Partitioning Tree.

    Written by Bryce Summers on 6/26/2016.
    
    Purpose:
     - This class enable efficient geometric queries by partitioning planar space using surfaces.
 */

(function() {
  BT2D.BSP = (function() {

    /*
    
        Creating the BSP.
     */
    function BSP(surfaceSet) {
      console.log("Implement Me!");
      debugger;
      this._bp;
      this._left;
      this._set;
      this._right;
    }

    BSP.prototype._choosePartitioner = function(surfaceSet) {};

    BSP.prototype._partitionInput = function(bp) {};


    /*
    
        Search Queries using the BSP.
     */

    BSP.prototype.intersectRay = function(ray, intersection, min_time) {
      var bp_intersection_time, classification, otherSide, pt, ptSide, ref;
      pt = ray.getPosition(min_time);
      classification = this._bp.side_test(pt);
      ref = this._orientChildSets(classification), ptSide = ref[0], otherSide = ref[1];
      if (ptSide !== null && ptSide.intersectRay(ray, intersection, min_time)) {
        return true;
      }
      if (this._set.intersectRay(ray, intersection)) {
        return true;
      }
      if (otherSide === null) {
        return false;
      }
      bp_intersection_time = this._bp.ray_partition_intersection(ray);
      if (bp_intersection_time < min_time) {
        return false;
      }
      return otherSide.intersectRay(ray, intersection, bp_intersection_time);
    };

    BSP.prototype._orientChildSets = function(classification) {
      switch (classification) {
        case BT2D.Constants.LEFT:
          return [_left, _right];
        case BT2D.Constants.RIGHT:
          return [_right, _left];
        case BT2D.Constants.ON:
          console.log("ERROR: We are assuming starting points that are not on a binary classification boundary.");
          debugger;
      }
    };

    BSP.prototype.intersectFrustrum = function(frustrum, min_time1, min_time2) {
      var bp_left, bp_right, classification_left, classification_right, classifier, focus, frustrum_side, intersections, left_frustrum, otherSide, pt_left, pt_right, ray_left, ray_right, ref, ref1, ref2, ref3, right_frustrum, time1, time2;
      bp_left = frustrum.getLeftBP();
      bp_right = frustrum.getRightBP();
      pt_left = bp_left.getPosition(min_time1);
      pt_right = bp_left.getPosition(min_time2);
      classification_left = this._bp.side_test(pt_left);
      classification_right = this._bp.side_test(pt_right);
      if (classification_left === BT2D.Constants.ON || classification_right === BT2D.Constants.ON) {
        console.log("ERROR: Assumption invalidated, frustum not offset into cell interior, try using a fudge factor.");
      }
      ray_left = bp_left;
      ray_right = bp_right;
      time1 = this._bp.ray_partition_intersection_time(ray_left);
      time2 = this._bp.ray_partition_intersection_time(ray_right);
      if (classification_left === classification_right) {
        classifier = classification_left;
      } else if (time1 === BT2D.Constants.NO_INTERSECTION && time2 !== BT2D.Constants.NO_INTERSECTION) {
        classifier = classification_right;
      } else if (time1 !== BT2D.Constants.NO_INTERSECTION && time2 === BT2D.Constants.NO_INTERSECTION) {
        classifier = classification_left;
      } else {
        focus = frustrum.getFocusPoint();
        if (focus === null) {
          classifier = classification_left;
        } else {
          classifier = this._bp.side_test(focus);
        }
      }
      ref = this._orientChildSets(classifier), frustrum_side = ref[0], otherSide = ref[1];
      ref1 = frustrum_side.intersectFrustrum(frustrum, min_time1, min_time2), left_frustrum = ref1[0], intersections = ref1[1], right_frustrum = ref1[2];
      if (intersections !== null) {
        return [left_frustrum, intersections, right_frustrum];
      }
      if (time1 === BT2D.Constants.NO_INTERSECTION && time2 === BT2D.Constants.NO_INTERSECTION) {
        return [null, null, null];
      }
      if (time1 === BT2D.Constants.NO_INTERSECTION) {
        time1 = Number.MAX_VALUE;
        console.log("Does this case actually happen?");
      }
      if (time2 === BT2D.Constants.NO_INTERSECTION) {
        time2 = Number.MAX_VALUE;
        console.log("Does this case actually happen?");
      }
      if (intersections === null) {
        ref2 = this._set.intersectFrustrum(frustrum, min_time1, min_time2), left_frustrum = ref2[0], intersections = ref2[1], right_frustrum = ref2[2];
      }
      if (intersections === null) {
        ref3 = otherSide.intersectFrustrum(frustrum, time1, time2), left_frustrum = ref3[0], intersections = ref3[1], right_frustrum = ref3[2];
      }
      return [left_frustrum, intersections, right_frustrum];
    };

    return BSP;

  })();

}).call(this);

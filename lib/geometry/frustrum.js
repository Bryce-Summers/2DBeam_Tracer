// Generated by CoffeeScript 1.10.0

/*
    Frustrum object.

    Written by Bryce Summers on 6/18/2016.
    
    Purpose:
     - This class represents the geometry of individual frustrums,
     - Along with associated starting and ending data and spectrum data.
     
     
    Representation:
     - The Frustrum is represented by 4 2D vector locations, 
       represented by 2 pairs of starting and ending points.
     - the ray start1 -> end1 is represented guranteed to be to the left ( counter-clockwise ) of start2 -> end2
     
     The frustrum is said to be complete then it has all 4 points, but imcomplete it it only has the near points defined.


    Frustrums have a notion of completeness, mono vs multiple directionality, and having a focus. Interpolation is linear for now...
 */

(function() {
  BT2D.Frustrum = (function() {
    function Frustrum(_start1, _start2, _dir1, _dir2) {
      this.original_start1 = _start1;
      this.original_start2 = _start2;
      this._dir1 = _dir1.clone();
      this._dir2 = _dir2.clone();
      this._dir1.normalize();
      this._dir2.normalize();
      this._start1 = _start1.clone();
      this._start2 = _start2.clone();
      this._end1 = null;
      this._end2 = null;
      this.mono_focused = (_start1 === _start2) || (this._start1.clone().sub(this._start2).length() < BT2D.Constants.EPSILON);
      this.checkDegenerate();
      this.checkBounds(this._start1, this._start2);
      this.validateOrientation();
    }

    Frustrum.prototype.checkDegenerate = function() {
      if (!this.mono_focused && this._start1.clone().sub(this._start2).length() < .001) {
        console.log("ERROR: this frustum has been set to a trivial area.");
        debugger;
      }
      if (this._dir1.length() > 2) {
        console.log("ERROR: improper direction  passed to frustrum!");
        debugger;
      }
      if (this._dir2.length() > 2) {
        console.log("ERROR: improper direction  passed to frustrum!");
        debugger;
      }
    };

    Frustrum.prototype.checkBounds = function(p1, p2) {
      if (p1.x < -50.0 - BT2D.Constants.EPSILON) {
        debugger;
      }
      if (p1.x > 50.0 + BT2D.Constants.EPSILON) {
        debugger;
      }
      if (p2.y < -50.0 - BT2D.Constants.EPSILON) {
        debugger;
      }
      if (p2.y > 50.0 + BT2D.Constants.EPSILON) {
        debugger;
      }
    };

    Frustrum.prototype.validateOrientation = function() {
      var bp_1, bp_2, classification1, classification2, pt1, pt2, ray1, ray2;
      ray1 = this.getLeftRay();
      bp_1 = this.getLeftBP();
      ray2 = this.getRightRay();
      bp_2 = this.getRightBP();
      pt1 = ray1.getPosition(1);
      pt2 = ray2.getPosition(1);
      classification1 = bp_2.side_test(pt1);
      classification2 = bp_1.side_test(pt2);
      if (classification1 > BT2D.Constants.ON) {
        console.log("ERROR: Validation failed");
      }
      if (classification2 < BT2D.Constants.ON) {
        console.log("ERROR: Validation failed");
      }
    };

    Frustrum.prototype.complete = function(end1, end2) {
      this._end1 = end1.clone();
      return this._end2 = end2.clone();
    };

    Frustrum.prototype.setLeftRay = function(ray) {
      this._start1 = ray.getOrigin();
      this._dir1 = ray.getDirection();
      this._dir1.normalize();
      return this.checkDegenerate();
    };

    Frustrum.prototype.setRightRay = function(ray) {
      this._start2 = ray.getOrigin();
      this._dir2 = ray.getDirection();
      this._dir2.normalize();
      return this.checkDegenerate();
    };

    Frustrum.prototype.getDir1 = function() {
      return this._dir1.clone();
    };

    Frustrum.prototype.getDir2 = function() {
      return this._dir2.clone();
    };

    Frustrum.prototype.getStart1 = function() {
      return this._start1.clone();
    };

    Frustrum.prototype.getStart2 = function() {
      return this._start2.clone();
    };

    Frustrum.prototype.getEnd1 = function() {
      return this._end1.clone();
    };

    Frustrum.prototype.getEnd2 = function() {
      return this._end2.clone();
    };

    Frustrum.prototype.getLeftBP = function() {
      return new BT2D.Line(this._start1, this._dir1, BT2D.Line.RAY);
    };

    Frustrum.prototype.getRightBP = function() {
      return new BT2D.Line(this._start2, this._dir2, BT2D.Line.RAY);
    };

    Frustrum.prototype.getLeftRay = function() {
      return new BT2D.Line(this._start1, this._dir1, BT2D.Line.RAY);
    };

    Frustrum.prototype.getRightRay = function() {
      return new BT2D.Line(this._start2, this._dir2, BT2D.Line.RAY);
    };

    Frustrum.prototype.getStartingBP = function() {
      if (this.mono_focused) {
        return null;
      }
      return new BT2D.Line(this._start1, this._start2, BT2D.Line.UNBOUNDED);
    };

    Frustrum.prototype.getFocusPoint = function() {
      var intersection, left, right;
      if (this.mono_focused) {
        return this._start1.clone();
      }
      left = this.getLeftRay();
      left.makeUnbounded();
      right = this.getRightRay().getInvert();
      left.makeUnbounded();
      intersection = new BT2D.Intersection();
      if (!left.intersectAny(right, intersection)) {
        return null;
      }
      return intersection.computePosition(right);
    };

    Frustrum.prototype.getSplitRay = function(pt) {
      var back_dir, back_split_ray, bp_start, dist1, dist2, focus, mono_direction, per_left, per_right, percentage, split_ray, split_start, time;
      bp_start = this.getStartingBP();
      focus = this.getFocusPoint();
      if (focus === null) {
        mono_direction = this.getLeftRay().getDirection();
        back_dir = mono_direction.clone().multiplyScalar(-1);
        back_split_ray = new BT2D.Line(pt, back_dir, BT2D.Line.RAY);
        percentage = back_split_ray.ray_partition_intersection_time(bp_start);
        percentage = Math.min(1.0, Math.max(percentage, 0.0));
        split_start = bp_start.getPosition(percentage);
        split_ray = new BT2D.Line(split_start, mono_direction, BT2D.Line.RAY);
        return [split_ray, percentage];
      }
      split_ray = new BT2D.Line(focus, pt);
      split_ray.makeRay();
      if (bp_start !== null) {
        time = split_ray.ray_partition_intersection_time(bp_start);
        split_start = split_ray.getPosition(time);
        dist1 = split_start.clone().sub(this._start1);
        dist2 = split_start.clone().sub(this._start2);
        percentage = dist1 / (dist1 + dist2);
        split_ray = new BT2D.Line(split_start, pt);
        split_ray.makeRay();
      } else {
        per_left = this.getLeftBP().side_test_scalar(pt);
        per_right = -this.getRightBP().side_test_scalar(pt);
        percentage = per_left / (per_left + per_right);
        percentage = Math.min(1.0, Math.max(percentage, 0.0));
      }
      return [split_ray, percentage];
    };

    return Frustrum;

  })();

}).call(this);

// Generated by CoffeeScript 1.10.0

/*
    Line object.

    Written by Bryce Summers on 6/18/2016.
    
    Purpose:
     - This class represents 2D line's in a purely geometric sense.
 */

(function() {
  BT2D.Line = (function() {
    var RAY, SEGMENT, UNBOUNDED;

    SEGMENT = 0;

    UNBOUNDED = 1;

    RAY = 2;

    function Line(_p1, _p2, _type1) {
      var temp;
      this._type = _type1;
      if (!(typeof _type !== "undefined" && _type !== null)) {
        this._type = SEGMENT;
      }
      if (this._type !== BT2D.Line.RAY) {
        this._p1 = _p1.clone();
        this._p2 = _p2.clone();
        this._offset = this._p2.clone().sub(this._p1);
        this._dir = this._offset.clone().normalize();
      } else {
        this._p1 = _p1.clone();
        this._offset = this._p2.clone().normalize();
        this._p2 = this._p1.clone().add(_offset);
        this._dir = this._offset.clone();
      }
      this._normal = this._dir.clone();
      temp = this._normal.x;
      this._normal.x = -this._normal.y;
      this._normal.y = temp;
    }

    Line.prototype.getInvert = function() {
      if (this._type !== BT2D.Line.RAY) {
        return new BT2D.Line(this._p2, this._p1, this._type);
      } else {
        return new BT2D.Line(this._p2, this._offset.clone().multiplyScalar(-1), this._type);
      }
    };

    Line.prototype.makeUnbounded = function() {
      return this._type = UNBOUNDED;
    };

    Line.prototype.makeRay = function() {
      return this._type = RAY;
    };

    Line.prototype.makeSegment = function() {
      return this._type = SEGMENT;
    };

    Line.prototype.getNormal = function() {
      return this._normal.clone();
    };

    Line.prototype.getP1 = function() {
      return this._p1.clone();
    };

    Line.prototype.getP2 = function() {
      return this._p2.clone();
    };

    Line.prototype.getOrigin = function() {
      return this._p1.clone();
    };

    Line.prototype.getDirection = function() {
      return this._offset.clone();
    };

    Line.prototype.getType = function() {
      return this._type;
    };

    Line.prototype.getPerfectSpecularReflectionDirection = function(incoming_direction) {
      var normal, normal_proj, normal_proj_mag;
      normal = this._normal;
      normal_proj_mag = incoming_direction.dot(normal);
      normal_proj = normal.clone().multiplyScalar(normal_proj_mag);
      if (normal_proj_mag < 0) {
        normal_proj.multiplyScalar(-1);
      }
      return incoming_direction.clone().sub(normal_proj.multiplyScalar(2));
    };

    Line.prototype.intersectAny = function(line, intersection) {
      var time;
      time = this._intersectRayTime(line);
      if (time === BT2D.Constants.NO_INTERSECTION) {
        return false;
      }
      intersection.time = time;
      return true;
    };

    Line.prototype.intersectRay = function(ray, intersection, min_time) {
      var time;
      time = this._intersectRayTime(ray);
      if ((time === BT2D.Constants.NO_INTERSECTION) || time < min_time) {
        return false;
      }
      if (time > min_time && (intersection.time === null || intersection.time > time)) {
        intersection.time = time;
      }
      return true;
    };

    Line.prototype._intersectRayTime = function(ray) {

      /*
      First of all, here is the intersection math.
      u = ((bs.y - as.y) * bd.x - (bs.x - as.x) * bd.y) / (bd.x * ad.y - bd.y * ad.x)
      v = ((bs.y - as.y) * ad.x - (bs.x - as.x) * ad.y) / (bd.x * ad.y - bd.y * ad.x)
      Factoring out the common terms, this comes to:
      dx = bs.x - as.x
      dy = bs.y - as.y
      det = bd.x * ad.y - bd.y * ad.x
      u = (dy * bd.x - dx * bd.y) / det
      v = (dy * ad.x - dx * ad.y) / det
       */
      var ad, as, bd, bs, det, dx, dy, ot, u, v;
      as = this._p1;
      bs = ray.getOrigin();
      ad = this._offset;
      bd = ray.getDirection();
      dx = bs.x - as.x;
      dy = bs.y - as.y;
      det = bd.x * ad.y - bd.y * ad.x;
      if (Math.abs(det) < .0001) {
        return BT2D.Constants.NO_INTERSECTION;
      }
      u = (dy * bd.x - dx * bd.y) / det;
      v = (dy * ad.x - dx * ad.y) / det;
      if (this._type !== UNBOUNDED && u < -0) {
        return BT2D.Constants.NO_INTERSECTION;
      }
      if (this._type === SEGMENT && u > 1) {
        return BT2D.Constants.NO_INTERSECTION;
      }
      ot = ray.getType();
      if (ot !== UNBOUNDED && v < -0) {
        return BT2D.Constants.NO_INTERSECTION;
      }
      if (ot === SEGMENT && v > 1) {
        return BT2D.Constants.NO_INTERSECTION;
      }
      return v;
    };

    Line.prototype.side_test = function(c) {
      return (this._p2.x - this._p1.x) * (c.y - this._p1.y) - (this._p2.y - this._p1.y) * (c.x - this._p1.x);
    };

    Line.prototype.representative_point = function() {
      return _p1.clone();
    };

    Line.prototype.ray_partition_intersection_time = function(ray) {
      var saveType, time;
      saveType = this._type;
      this.makeUnbounded();
      time = this._intersectRayTime();
      this._type = saveType;
      return time;
    };

    Line.prototype.getPosition = function(time) {
      var location, offset;
      offset = this.dir.clone();
      offset.multiplyScalar(time);
      location = getP1();
      location.add(offset);
      return location;
    };

    return Line;

  })();

}).call(this);

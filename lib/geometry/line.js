// Generated by CoffeeScript 1.10.0

/*
    Line object.

    Written by Bryce Summers on 6/18/2016.
    
    Purpose:
     - This class represents 2D line's in a purely geometric sense.
 */

(function() {
  BT2D.Line = (function() {
    function Line(_p1, _p2, _type) {
      var temp;
      this._type = _type != null ? _type : BT2D.Line.SEGMENT;
      if (this._type !== BT2D.Line.RAY) {
        this._p1 = _p1.clone();
        this._p2 = _p2.clone();
        this._offset = this._p2.clone().sub(this._p1);
        this._dir = this._offset.clone().normalize();
      } else {
        this._p1 = _p1.clone();
        this._offset = _p2.clone().normalize();
        this._p2 = this._p1.clone().add(this._offset);
        this._dir = this._offset.clone().normalize();
      }
      this._normal = this._dir.clone();
      temp = this._normal.x;
      this._normal.x = -this._normal.y;
      this._normal.y = temp;
    }

    Line.prototype.getInvert = function() {
      if (this._type !== BT2D.Line.RAY) {
        return new BT2D.Line(this._p2, this._p1, this._type);
      } else {
        return new BT2D.Line(this._p2, this._offset.clone().multiplyScalar(-1), this._type);
      }
    };

    Line.prototype.makeUnbounded = function() {
      return this._type = BT2D.Line.UNBOUNDED;
    };

    Line.prototype.makeRay = function() {
      return this._type = BT2D.Line.RAY;
    };

    Line.prototype.makeSegment = function() {
      return this._type = BT2D.Line.SEGMENT;
    };

    Line.prototype.getNormal = function() {
      return this._normal.clone();
    };

    Line.prototype.getP1 = function() {
      return this._p1.clone();
    };

    Line.prototype.getP2 = function() {
      return this._p2.clone();
    };

    Line.prototype.getOrigin = function() {
      return this._p1.clone();
    };

    Line.prototype.getDirection = function() {
      return this._offset.clone();
    };

    Line.prototype.getType = function() {
      return this._type;
    };

    Line.prototype.getPerfectSpecularReflectionDirection = function(incoming_direction) {
      var cosI, normal, output, perp_component;
      normal = this._normal.clone();
      cosI = normal.dot(incoming_direction);
      perp_component = normal.multiplyScalar(2 * cosI);
      output = incoming_direction.clone();
      output.sub(perp_component);
      return output;
    };

    Line.prototype.getFrontNormal = function(incoming_direction) {
      var output;
      output = this._normal.clone();
      if (output.dot(incoming_direction) > 0) {
        output.multiplyScalar(-1);
      }
      return output;
    };

    Line.prototype.intersectAny = function(line, intersection) {
      var time;
      time = this._intersectRayTime(line);
      if (time === BT2D.Constants.NO_INTERSECTION) {
        return false;
      }
      intersection.time = time;
      return true;
    };

    Line.prototype.intersectRay = function(ray, intersection, min_time) {
      var time;
      time = this._intersectRayTime(ray);
      if (time === BT2D.Constants.NO_INTERSECTION) {
        return false;
      }
      if (intersection.time !== null && intersection.time < time) {
        return false;
      }
      intersection.time = time;
      return true;
    };

    Line.prototype.intersectFrustrum = function(lightFrustrum, min_time1, min_time2) {
      var bp_left, bp_right, bp_start, c_l_l, c_l_r, c_r_l, c_r_r, dist1, dist2, end1, end2, focus, frustrum, i_left, i_right, intersection1, intersection2, intersection_exists, intersection_left, intersection_right, left_frustrum, pt_left, pt_left2, pt_right, pt_right2, ray1, ray2, ref, ref1, right_frustrum, t_left, t_right;
      if (lightFrustrum.source_geometry === this) {
        return [false, null, null, null];
      }
      frustrum = lightFrustrum.frustrum;
      bp_left = frustrum.getLeftBP();
      bp_right = frustrum.getRightBP();
      ray1 = bp_left;
      ray2 = bp_right;
      ref = bp_left.orientPts(this._p1, this._p2), pt_left = ref[0], pt_right = ref[1];
      ref1 = bp_right.orientPts(this._p1, this._p2), pt_left2 = ref1[0], pt_right2 = ref1[1];
      c_l_l = bp_left.side_test(pt_left);
      c_l_r = bp_left.side_test(pt_right);
      c_r_l = bp_right.side_test(pt_left2);
      c_r_r = bp_right.side_test(pt_right2);
      bp_start = frustrum.getStartingBP();
      intersection_exists = false;
      if ((c_l_l >= BT2D.Constants.ON && c_r_l < BT2D.Constants.ON) || (c_l_r > BT2D.Constants.ON && c_r_r <= BT2D.Constants.ON)) {
        if (bp_start === null || bp_start.side_test(pt_left) < BT2D.Constants.ON || bp_start.side_test(pt_right) < BT2D.Constants.ON) {
          intersection_exists = true;
        }
      }

      /*
      intersection_exists = true
      
      
       * left point is on or to the right of the right ray.
      if c_r_l >= BT2D.Constants.ON
          intersection_exists = false
      
      if c_l_r <= BT2D.Constants.ON
          intersection_exists = false
      
       * if both points are on the non frustrum side of the flat starting front of the frustrum,
       * then there can be no intersection.
      if bp_start != null and
         bp_start.side_test(pt_left) >= BT2D.Constants.ON and
         bp_start.side_test(pt_right) >= BT2D.Constants.ON
          intersection_exists = false
       */
      intersection_left = new BT2D.Intersection();
      intersection_right = new BT2D.Intersection();
      bp_left.intersectAny(this, intersection_left);
      bp_right.intersectAny(this, intersection_right);
      t_left = intersection_left.time;
      t_right = intersection_right.time;
      if (this._p1 !== pt_left) {
        if (t_left !== BT2D.Constants.NO_INTERSECTION) {
          t_left = 1.0 - t_left;
        }
      }
      if (this._p1 !== pt_left2) {
        if (t_right !== BT2D.Constants.NO_INTERSECTION) {
          t_right = 1.0 - t_right;
        }
      }
      i_left = t_left !== BT2D.Constants.NO_INTERSECTION && t_left < 1.0 - BT2D.Constants.EPSILON;
      i_right = t_right !== BT2D.Constants.NO_INTERSECTION && t_right > 0.0 + BT2D.Constants.EPSILON;
      if (i_left || i_right) {
        intersection_exists = true;
      }

      /*
      t_left  = @ray_partition_intersection_time(bp_left)
      t_right = @ray_partition_intersection_time(bp_right)
      
      if @_p1 != pt_left
          if t_left != BT2D.Constants.NO_INTERSECTION
              t_left2 = 1.0 - t_left
      
          if t_right != BT2D.Constants.NO_INTERSECTION
              t_right2 = 1.0 - t_right
      
      if @_p1 != pt_left2
          if t_left != BT2D.Constants.NO_INTERSECTION
              t_left3 = 1.0 - t_left
      
          if t_right != BT2D.Constants.NO_INTERSECTION
              t_right3 = 1.0 - t_right
      
      i_left_of_line = 
      
      if t_left == BT2D.Constants.NO_INTERSECTION and
       */
      if (!intersection_exists) {
        return [false, null, null, null];
      }
      intersection1 = new BT2D.Intersection();
      intersection2 = new BT2D.Intersection();
      if (i_left && i_right) {
        this.intersectRay(ray1, intersection1, min_time1);
        this.intersectRay(ray2, intersection2, min_time2);
        end1 = intersection1.computePosition(ray1);
        end2 = intersection2.computePosition(ray2);
        lightFrustrum.complete(end1, end2, intersection1.time, intersection2.time);
        return [true, null, null, null];
      }
      bp_start = frustrum.getStartingBP();
      focus = frustrum.getFocusPoint();
      left_frustrum = null;
      right_frustrum = null;
      if (!i_left) {
        left_frustrum = lightFrustrum.splitLeft(pt_left2);
        pt_left = pt_left2;
      } else {
        this.intersectRay(ray1, intersection1, min_time1);
        pt_left = intersection1.computePosition(ray1);
      }
      if (!i_right) {
        right_frustrum = lightFrustrum.splitRight(pt_right);
      } else {
        this.intersectRay(ray2, intersection2, min_time2);
        pt_right = intersection2.computePosition(ray2);
      }
      dist1 = pt_left.clone().sub(frustrum.getStart1()).length();
      dist2 = pt_right.clone().sub(frustrum.getStart2()).length();
      lightFrustrum.complete(pt_left, pt_right, dist1, dist2);
      console.log(lightFrustrum);
      return [true, left_frustrum, right_frustrum, null];
    };

    Line.prototype._intersectRayTime = function(ray) {

      /*
      First of all, here is the intersection math.
      u = ((bs.y - as.y) * bd.x - (bs.x - as.x) * bd.y) / (bd.x * ad.y - bd.y * ad.x)
      v = ((bs.y - as.y) * ad.x - (bs.x - as.x) * ad.y) / (bd.x * ad.y - bd.y * ad.x)
      Factoring out the common terms, this comes to:
      dx = bs.x - as.x
      dy = bs.y - as.y
      det = bd.x * ad.y - bd.y * ad.x
      u = (dy * bd.x - dx * bd.y) / det
      v = (dy * ad.x - dx * ad.y) / det
       */
      var ad, as, bd, bs, det, dx, dy, ot, u, v;
      as = this._p1;
      bs = ray.getOrigin();
      ad = this._offset;
      bd = ray.getDirection();
      dx = bs.x - as.x;
      dy = bs.y - as.y;
      det = bd.x * ad.y - bd.y * ad.x;
      if (Math.abs(det) < .0001) {
        return BT2D.Constants.NO_INTERSECTION;
      }
      u = (dy * bd.x - dx * bd.y) / det;
      v = (dy * ad.x - dx * ad.y) / det;
      if (this._type !== BT2D.Line.UNBOUNDED && u < -BT2D.Constants.EPSILON) {
        return BT2D.Constants.NO_INTERSECTION;
      }
      if (this._type === BT2D.Line.SEGMENT && u > 1 + BT2D.Constants.EPSILON) {
        return BT2D.Constants.NO_INTERSECTION;
      }
      ot = ray.getType();
      if (ot !== BT2D.Line.UNBOUNDED && v < -BT2D.Constants.EPSILON * 1.5) {
        return BT2D.Constants.NO_INTERSECTION;
      }
      if (ot === BT2D.Line.SEGMENT && v > 1 + BT2D.Constants.EPSILON * 1.5) {
        return BT2D.Constants.NO_INTERSECTION;
      }
      return v;
    };

    Line.prototype.side_test = function(pt) {
      var val;
      val = this.side_test_scalar(pt);
      if (Math.abs(val) < BT2D.Constants.EPSILON) {
        return BT2D.Constants.ON;
      }
      if (val < 0) {
        return BT2D.Constants.LEFT;
      }
      if (val > 0) {
        return BT2D.Constants.RIGHT;
      }
      return console.log("Impossible to get here!");
    };

    Line.prototype.side_test_scalar = function(c) {
      return (this._p1.x - this._p2.x) * (c.y - this._p2.y) - (this._p1.y - this._p2.y) * (c.x - this._p2.x);
    };

    Line.prototype.representative_point = function() {
      return _p1.clone();
    };

    Line.prototype.ray_partition_intersection_time = function(ray) {
      var saveType, time;
      saveType = this._type;
      this.makeUnbounded();
      time = this._intersectRayTime(ray);
      this._type = saveType;
      return time;
    };

    Line.prototype.getPosition = function(time) {
      var location, offset;
      offset = this.getDirection();
      offset.multiplyScalar(time);
      location = this.getOrigin();
      location.add(offset);
      return location;
    };

    Line.prototype.split = function(bp) {
      var out1, out2, pt_split, side1, side2, time;
      time = bp.ray_partition_intersection_time(this);
      side1 = bp.side_test(this._p1);
      side2 = bp.side_test(this._p2);
      if (time === BT2D.Constants.NO_INTERSECTION || (side1 === side2 && this._type === BT2D.Line.SEGMENT)) {
        if (side1 < 0) {
          return [this, null, null];
        }
        if (side1 === 0) {
          return [null, this, null];
        }
        if (side1 > 0) {
          return [null, null, this];
        }
      }
      pt_split = this.getPosition(time);
      switch (this._type) {
        case BT2D.Line.UNBOUNDED:
          out1 = new BT2D.Line(pt_split, this._dir.clone().multiplyScalar(-1), BT2D.Line.RAY);
          out2 = new BT2D.Line(pt_split, this._dir, BT2D.Line.RAY);
          break;
        case BT2D.Line.RAY:
          out1 = new BT2D.Line(this._p1, pt_split, BT2D.Line.SEGMENT);
          out2 = new BT2D.Line(pt_split, this._dir, BT2D.Line.RAY);
          break;
        case BT2D.Line.SEGMENT:
          out1 = new BT2D.Line(this._p1, pt_split, BT2D.Line.SEGMENT);
          out2 = new BT2D.Line(pt_split, this._p2, BT2D.Line.SEGMENT);
          break;
      }
      if (side1 < 0) {
        return [out1, null, out2];
      }
      return [out2, null, out1];
    };

    Line.prototype.orientPts = function(pt1, pt2) {
      var side1, side2;
      side1 = this.side_test_scalar(pt1);
      side2 = this.side_test_scalar(pt2);
      if (side1 < side2) {
        return [pt1, pt2];
      }
      return [pt2, pt1];
    };

    Line.prototype._radiallyOrientPts = function(lightFrustrum, pt1, pt2) {
      var classification, orientation_ray;
      orientation_ray = lightFrustrum.getSplitRay(pt1);
      classification = orientation_ray.side_test(pt2);
      if (classification <= BT2D.Constants.ON) {
        return [pt1, pt2];
      }
      return [pt2, pt1];
    };

    return Line;

  })();

  BT2D.Line.SEGMENT = 0;

  BT2D.Line.UNBOUNDED = 1;

  BT2D.Line.RAY = 2;

}).call(this);
